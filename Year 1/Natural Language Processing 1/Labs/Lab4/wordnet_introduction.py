# -*- coding: utf-8 -*-
"""wordnet_introduction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ORf-uRptsIqfZLIrRS3yfZanLE3Ldvgr
"""

from google.colab import files, auth, drive

# Mount to drive
drive.mount('/content/gdrive', force_remount=True)
data_dir_drive ='/content/gdrive/My Drive/Colab Notebooks/NLP1/Lab4'

! pip install nltk

import nltk
nltk.download()

"""# **Wordnet**"""

# Wordnet is a semantic dictionary organized into synsets (synonim rings). 
# A synset is a group of synonym words and has an associated id and sense 
# (a word can appear in multiple synsets if that word (or collocation) 
# is polysemantic) illustrated by a brief gloss.
# To easily visualize the links between words, you can use this web based 

from nltk.corpus import wordnet
print(wordnet.synsets('school'))
print(wordnet.synsets('schooled'))
print(wordnet.synsets('cats'))

"""Types of relations (for nouns):"""

# hypernyms/hyponyms
sch=wordnet.synset('school.n.01')
print(sch.hyponyms())
                                            
print(sch.hypernyms())

# meronyms/holonyms of three types (withe the prefixes in parentheses): 
# "part of" ("part_"), "substance" ("substance_"), "member of" ("member_").
aer=wordnet.synset('air.n.01')
print(aer.substance_holonyms())
print(aer.substance_meronyms())
                                            
house=wordnet.synset('house.n.01')
print(house.part_holonyms())
print(house.part_meronyms())
                                            
tree=wordnet.synset('tree.n.01')
print(tree.member_holonyms())
print(tree.member_meronyms())
print(tree.part_meronyms())

# attributes (relation to adjective synsets)
wordnet.synset('strength.n.01').attributes()

"""Types of relations (for verbs):"""

# hypernyms/troponyms. Troponyms give a specification for the verb (a verb that 
# specifies the same action but in a certain context. For example, diving is a 
# type of swimming, therefore the verb dive is a troponym for the verb swim).
vb=wordnet.synset('run.v.01')
print(vb.hypernyms())
print(vb.hyponyms())

# entailments (an action(verb) is dependent on another action (verb) - the 
# first action needs the other action to take place)
wordnet.synset('look.v.01').entailments()

# verb_groups
wordnet.synset('quiz.v.01').verb_groups()

"""Types of relations (for adjectives):"""

# antonyms
lem=wordnet.synset('good.a.01').lemmas()[0]
lem.antonyms()

# similar to (also for adjective satellites)
wordnet.synset('strong.a.01').similar_tos()

# pertainyms (can be nouns or other adjectives). Concepts(synsets) that pertain to the given synset
lem=wordnet.synset('technical.a.01').lemmas()[0]
lem.pertainyms()

# attributes (relation to noun synsets)
wordnet.synset('strong.a.01').attributes()

"""Types of relations (for adverbs):"""

# antonyms
wordnet.synset('quickly.r.01').lemmas()[0].antonyms()

# pertainyms (can be nouns or other adjectives). Concepts(synsets) that pertain to the given synset
wordnet.synset('quickly.r.01').lemmas()[0].pertainyms()

# The similarity of two synsets:
tree=wordnet.synset('tree.n.01')
print(tree.path_similarity(wordnet.synset('plant.n.01')))
print(tree.path_similarity(wordnet.synset('car.n.01')))
print(tree.path_similarity(wordnet.synset('public_school.n.01')))

"""# **Exercises and homework**

# **1**
Create a function that receives a word and prints the associated glosses for all the possible senses of that word (you must find all its corresponding synsets and print the gloss for each).
"""

def get_all_definitions(word):
    syn_sets = wordnet.synsets(word)
    for i, syn in enumerate(syn_sets):
        print(i + 1, syn.definition())

get_all_definitions('car')

"""# **2**
Create a function that receives two words as parameters. The function will check, using WordNet if the two words can be synonyms (there is at least one synset that contains the two words). If such synset is found, print the gloss for that synset.
"""

def check_synonyms(word1, word2):
    syn_sets1 = wordnet.synsets(word1)
    syn_sets2 = wordnet.synsets(word2)
    #print(syn_sets1)
    #print(syn_sets2)
    for syn in syn_sets1:
        if syn in syn_sets2:
            return syn.definition()
    return "words are not synonyms"

syn = check_synonyms('end', 'finish')
print(syn)

"""# **3**
Create a function that receives a synset object and returns a tuple with 2 lists. The first list contains the holonyms (all types of holonyms) and the second one the meronyms (all types). Find a word that has either holonyms or meronyms of different types. Print them separately (on cathegories of holonyms/meronyms) and then all together using the created function (in order to check that it prints them all).
"""

def get_holonyms_meronyms(synset):
    return (synset.substance_holonyms() + synset.part_holonyms() + synset.member_holonyms(), synset.substance_meronyms() + synset.part_meronyms() + synset.member_meronyms())

synset = wordnet.synsets('earth')[0]
(holonyms, meronyms) = get_holonyms_meronyms(synset)
print(holonyms)
print(meronyms)
print()

print(synset.substance_holonyms())
print(synset.part_holonyms())
print(synset.member_holonyms())

print(synset.substance_meronyms())
print(synset.part_meronyms())
print(synset.member_meronyms())

"""# **4**
Create a function that for a given synset, prints the path of hypernyms (going to the next hypernym, and from that hypernym to the next one and so on, until it reaches the root).
"""

def get_all_hypernyms(synset):
    print(synset)
    synset = synset.hypernyms()
    if synset != []:
        get_all_hypernyms(synset[0])

get_all_hypernyms(wordnet.synsets('iron')[0])

"""# **5**
Create a function that receives two synsets as parameters. We consider d1(k) the length of the path from the first word to the hypernym k (the length of the path is the number of hypernyms it goes through, to reach k) and d2(k) the length of the path from the second word to the hypernym k. The function will return the list of hypernyms having the property that d1(k)+d2(k) is minimum (there can be multiple hypernyms with this property ; all having equal distances that are this minimum number; you must print them all).
"""

def print_LCA_paths(synset1, synset2):
    def get_all_paths_hypernyms(synset, depth = 0):
        L = []
        L.append((synset, depth))
        synset = synset.hypernyms()
        for syn in synset:
            L += (get_all_paths_hypernyms(syn, depth + 1))
        return L

    L1 = get_all_paths_hypernyms(synset1)
    L2 = get_all_paths_hypernyms(synset2)

    for l in L1:
        print(l)
    print()
    for l in L2:
        print(l)

    def complete_all_paths_hypernyms(path):
        L = []
        path = path[::-1]
        cut = 0
        while cut is not None:
            prev_node = path[0]
            l = [path[0]]
            cut = None
            for i in range(1, len(path)):
                if path[i][1] + 1 == prev_node[1]:
                    l.append(path[i])
                    prev_node = path[i]
                else:
                    cut = i
                    for j in range(i+1, len(path)):
                        if path[j][1] + 1 == prev_node[1]:
                            l.append(path[j])
                            prev_node = path[j]
                        else:
                            continue
                    break
            L.append(l[::-1])
            path = path[cut:]
        return L

    L1 = complete_all_paths_hypernyms(L1)
    L2 = complete_all_paths_hypernyms(L2)

    for l in L1:
        print(l)
    print()
    for l in L2:
        print(l)

    paths = []
    for l1 in range(len(L1)):
        for l2 in range(l1+1, len(L2)):
            for k in range(min(len(L1[l1]), len(L2[l2]))):
                if L1[l1][k] == L2[l2][k]:
                    paths.append(L1[l1][:k+1] + L2[l2][:k][::-1])
                    break

    return paths

paths = print_LCA_paths(wordnet.synsets('iron')[0], wordnet.synsets('copper')[0])
print()
print(paths)

"""# **6**
Create a function that receives a synset object and a list of synsets (the list must contain at least 5 elements). The function will return a sorted list. The list will be sorted by the similarity between the first synset and the synsets in the list. For example (we consider we take the firs synset for each word) we can test for the word cat and the list: animal, tree, house, object, public_school, mouse.
"""

def sort_by_similarity(syn, synset_list):
    L = []
    for s in synset_list:
        L.append((s, syn.path_similarity(s)))

    L = sorted(L, key=lambda tup: tup[1])
    return L

L = sort_by_similarity(wordnet.synsets('cat')[0], [wordnet.synsets('animal')[0], 
                                                  wordnet.synsets('tree')[0], 
                                                  wordnet.synsets('object')[0], 
                                                  wordnet.synsets('house')[0], 
                                                  wordnet.synsets('public_school')[0], 
                                                  wordnet.synsets('mouse')[0]])
print(L)

"""# **7**
Create a function that checks if two synsets can be indirect meronyms for the same synset. An indirect meronym is either a part of the givem element or a part of a part of the given element (and we can exten this relation as being part of part of part of etc....). This applies to any type of meronym.
"""

def check_shared_meronyms(syn1, syn2):

    def get_all_meronyms(syn):
        meronyms = set()
        meronyms.update(syn.substance_meronyms())
        meronyms.update(syn.part_meronyms())
        meronyms.update(syn.member_meronyms())
        update = True
        while update:
            initial_len = len(meronyms)
            L = []
            for meronym in meronyms:
                L += meronym.substance_meronyms() + meronym.part_meronyms() + meronym.member_meronyms()
            meronyms.update(L)
            final_len = len(meronyms)
            if initial_len == final_len:
                update = False
        return meronyms

    meronyms1 = get_all_meronyms(syn1)
    meronyms2 = get_all_meronyms(syn2)
    print(meronyms1)
    print(meronyms2)

    R = []
    for m in meronyms1:
        if m in meronyms2:
            R.append(m)

    return R

R = check_shared_meronyms(wordnet.synsets('earth')[0], wordnet.synsets('ice')[0])
print(R)

"""# **8**
Print the synonyms and antonyms of an adjective (for example, "beautiful"). If it's polisemantic, print them for each sense, also printing the gloss for that sense (synset).
"""

def get_synonyms_and_antonyms(adj):
    synsets = wordnet.synsets(adj)
    for syn in synsets:
        print(syn.definition())
        print(list(map(lambda x: x.lemma_names(), syn.similar_tos())))
        print(list(map(lambda x: x.name(), syn.lemmas()[0].antonyms())))
        print()

get_synonyms_and_antonyms('beautiful')